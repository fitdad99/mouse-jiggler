<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouse Jiggler - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: background 0.5s ease;
        }

        body.theme-ocean {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        body.theme-sunset {
            background: linear-gradient(135deg, #ff7e5f 0%, #feb47b 100%);
        }

        body.theme-forest {
            background: linear-gradient(135deg, #134e5e 0%, #71b280 100%);
        }

        body.theme-galaxy {
            background: linear-gradient(135deg, #2c3e50 0%, #4a569d 100%);
        }

        body.theme-aurora {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        body.theme-fire {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }

        body.theme-midnight {
            background: linear-gradient(135deg, #232526 0%, #414345 100%);
        }

        body.theme-custom {
            /* Will be set dynamically */
        }

        /* Background resistance indicators */
        .activity-indicator {
            position: fixed;
            top: 10px;
            left: 10px;
            width: 12px;
            height: 12px;
            background: #00ff00;
            border-radius: 50%;
            animation: pulse 2s infinite;
            z-index: 9999;
        }

        .background-status {
            position: fixed;
            top: 10px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 11px;
            z-index: 9998;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            text-align: center;
            min-width: 400px;
        }

        h1 {
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .status {
            margin-bottom: 30px;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .status.inactive {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
        }

        .status.active {
            background: rgba(76, 217, 100, 0.2);
            border: 1px solid rgba(76, 217, 100, 0.5);
        }

        .controls {
            margin-bottom: 30px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            margin-bottom: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .range-value {
            font-size: 0.9em;
            opacity: 0.8;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            color: white;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin: 0 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button.stop {
            background: linear-gradient(45deg, #ffa726, #ff9800);
        }

        .theme-bubble {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .theme-toggle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.3);
        }

        .theme-panel {
            position: absolute;
            top: 70px;
            right: 0;
            min-width: 300px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .theme-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .theme-panel h3 {
            margin: 0 0 15px 0;
            font-size: 1.1em;
            font-weight: 600;
        }

        .theme-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }

        .theme-option {
            width: 100%;
            height: 40px;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .theme-option:hover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theme-option.active {
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .theme-option.ocean { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .theme-option.sunset { background: linear-gradient(135deg, #ff7e5f 0%, #feb47b 100%); }
        .theme-option.forest { background: linear-gradient(135deg, #134e5e 0%, #71b280 100%); }
        .theme-option.galaxy { background: linear-gradient(135deg, #2c3e50 0%, #4a569d 100%); }
        .theme-option.aurora { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
        .theme-option.fire { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); }
        .theme-option.midnight { background: linear-gradient(135deg, #232526 0%, #414345 100%); }

        .custom-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 15px 0;
        }

        .custom-color-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .color-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .color-input-group label {
            font-size: 0.85em;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
        }

        .info {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .stats {
            margin-top: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .invisible-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
    </style>
</head>
<body>
    <!-- Activity indicators -->
    <div class="activity-indicator" id="activityIndicator"></div>
    <div class="background-status" id="backgroundStatus">Foreground</div>

    <div class="invisible-area" id="invisibleArea"></div>
    
    <div class="theme-bubble">
        <div class="theme-toggle" id="themeToggle">🎨</div>
        <div class="theme-panel" id="themePanel">
            <h3>Background Themes</h3>
            <div class="theme-grid">
                <div class="theme-option ocean active" data-theme="ocean" title="Ocean"></div>
                <div class="theme-option sunset" data-theme="sunset" title="Sunset"></div>
                <div class="theme-option forest" data-theme="forest" title="Forest"></div>
                <div class="theme-option galaxy" data-theme="galaxy" title="Galaxy"></div>
                <div class="theme-option aurora" data-theme="aurora" title="Aurora"></div>
                <div class="theme-option fire" data-theme="fire" title="Fire"></div>
                <div class="theme-option midnight" data-theme="midnight" title="Midnight"></div>
            </div>
            <div class="custom-divider"></div>
            <div class="custom-color-inputs">
                <div class="color-input-group">
                    <label for="color1">Start Color</label>
                    <input type="color" id="color1" value="#667eea">
                </div>
                <div class="color-input-group">
                    <label for="color2">End Color</label>
                    <input type="color" id="color2" value="#764ba2">
                </div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h1>🖱️ Mouse Jiggler Enhanced</h1>
        
        <div class="status inactive" id="status">
            Inactive - Click Start to begin
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="interval">Jiggle Interval (seconds)</label>
                <input type="range" id="interval" min="5" max="300" value="30">
                <div class="range-value" id="intervalValue">30 seconds</div>
            </div>

            <div class="control-group">
                <label for="distance">Movement Distance (pixels)</label>
                <input type="range" id="distance" min="1" max="10" value="3">
                <div class="range-value" id="distanceValue">3 pixels</div>
            </div>
        </div>

        <div>
            <button id="startBtn" onclick="startJiggler()">Start Jiggling</button>
            <button id="stopBtn" class="stop" onclick="stopJiggler()" style="display: none;">Stop</button>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="jigglesCount">0</div>
                <div>Jiggles Performed</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="uptime">00:00:00</div>
                <div>Active Time</div>
            </div>
        </div>

        <div class="info">
            <strong>Enhanced Features:</strong><br>
            ✅ Works in background tabs (Web Workers)<br>
            ✅ Multiple activity detection methods<br>
            ✅ Enhanced Teams compatibility<br>
            ✅ Real-time activity monitoring<br><br>
            <strong>Status:</strong> Green dot = Active | Background indicator shows tab state
        </div>
    </div>

    <script>
        let jiggleInterval;
        let uptimeInterval;
        let pageActivityInterval;
        let backgroundWorker = null;
        let startTime;
        let jigglesPerformed = 0;
        let isActive = false;
        let currentTheme = 'ocean';

        const statusEl = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const intervalSlider = document.getElementById('interval');
        const distanceSlider = document.getElementById('distance');
        const intervalValue = document.getElementById('intervalValue');
        const distanceValue = document.getElementById('distanceValue');
        const jigglesCount = document.getElementById('jigglesCount');
        const uptime = document.getElementById('uptime');
        const invisibleArea = document.getElementById('invisibleArea');
        const color1Input = document.getElementById('color1');
        const color2Input = document.getElementById('color2');
        const themeToggle = document.getElementById('themeToggle');
        const themePanel = document.getElementById('themePanel');
        const activityIndicator = document.getElementById('activityIndicator');
        const backgroundStatus = document.getElementById('backgroundStatus');

        // Background-resistant timer using multiple approaches
        function createBackgroundResistantTimer(callback, interval) {
            let timeouts = [];
            let isTimerActive = true;
            
            // Method 1: Standard setTimeout with recursive scheduling
            function scheduleTimeout() {
                if (!isTimerActive) return;
                const timeout = setTimeout(() => {
                    if (isTimerActive) {
                        callback();
                        scheduleTimeout();
                    }
                }, interval);
                timeouts.push(timeout);
            }
            
            // Method 2: MessageChannel for immediate execution
            const channel = new MessageChannel();
            let messageScheduled = false;
            channel.port2.onmessage = () => {
                if (isTimerActive && !messageScheduled) {
                    messageScheduled = true;
                    setTimeout(() => {
                        if (isTimerActive) {
                            callback();
                            messageScheduled = false;
                            if (isTimerActive) channel.port1.postMessage('');
                        }
                    }, interval);
                }
            };
            
            // Method 3: Web Worker timer (most background-resistant)
            const workerCode = `
                let intervalId;
                self.onmessage = function(e) {
                    if (e.data.command === 'start') {
                        intervalId = setInterval(() => {
                            self.postMessage('tick');
                        }, e.data.interval);
                    } else if (e.data.command === 'stop') {
                        if (intervalId) {
                            clearInterval(intervalId);
                            intervalId = null;
                        }
                    }
                };
            `;
            
            try {
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                backgroundWorker = new Worker(URL.createObjectURL(blob));
                backgroundWorker.onmessage = () => {
                    if (isTimerActive) callback();
                };
                backgroundWorker.postMessage({ command: 'start', interval: interval });
                console.log('✅ Web Worker timer created successfully');
            } catch (error) {
                console.log('❌ Worker creation failed, using fallback timers:', error);
            }
            
            // Start all methods
            scheduleTimeout();
            channel.port1.postMessage('');
            
            return {
                stop: () => {
                    isTimerActive = false;
                    timeouts.forEach(clearTimeout);
                    if (backgroundWorker) {
                        backgroundWorker.postMessage({ command: 'stop' });
                        backgroundWorker.terminate();
                        backgroundWorker = null;
                    }
                }
            };
        }

        function jiggleMouse() {
            console.log(`🐭 Enhanced jiggler activated at ${new Date().toLocaleTimeString()}`);
            
            // Enhanced activity methods with more aggressive techniques
            const methods = [
                () => {
                    // Method 1: Multiple mouse events with strategic coordinates
                    const coords = [
                        { x: Math.floor(Math.random() * window.innerWidth), y: Math.floor(Math.random() * window.innerHeight) },
                        { x: window.innerWidth / 2, y: window.innerHeight / 2 },
                        { x: 1, y: 1 },
                        { x: window.innerWidth - 1, y: window.innerHeight - 1 },
                        { x: 100, y: 100 } // Fixed position for consistency
                    ];
                    
                    coords.forEach((coord, i) => {
                        setTimeout(() => {
                            ['mousemove', 'mousedown', 'mouseup', 'click'].forEach(eventType => {
                                const event = new MouseEvent(eventType, {
                                    view: window,
                                    bubbles: true,
                                    cancelable: true,
                                    clientX: coord.x,
                                    clientY: coord.y,
                                    screenX: coord.x + window.screenX,
                                    screenY: coord.y + window.screenY,
                                    buttons: eventType === 'mousedown' ? 1 : 0,
                                    button: 0
                                });
                                document.dispatchEvent(event);
                                document.body.dispatchEvent(event);
                                if (invisibleArea) invisibleArea.dispatchEvent(event);
                            });
                        }, i * 20);
                    });
                },
                
                () => {
                    // Method 2: Multiple keyboard events (function keys)
                    const keys = ['F15', 'F16', 'F17', 'F18', 'F19', 'F20', 'F21', 'F22'];
                    keys.forEach((key, i) => {
                        setTimeout(() => {
                            ['keydown', 'keypress', 'keyup'].forEach((eventType, j) => {
                                const event = new KeyboardEvent(eventType, {
                                    key: key,
                                    code: key,
                                    which: 126 + i,
                                    keyCode: 126 + i,
                                    bubbles: true,
                                    cancelable: true,
                                    view: window
                                });
                                document.dispatchEvent(event);
                                window.dispatchEvent(event);
                            });
                        }, i * 25);
                    });
                },
                
                () => {
                    // Method 3: Focus cycling and window events
                    const elements = [window, document, document.body, document.documentElement];
                    elements.forEach((element, i) => {
                        setTimeout(() => {
                            try {
                                if (element.focus) element.focus();
                                setTimeout(() => {
                                    if (element.blur) element.blur();
                                }, 15);
                                
                                // Window focus events
                                ['focus', 'blur'].forEach(eventType => {
                                    const event = new FocusEvent(eventType, { bubbles: true });
                                    if (element.dispatchEvent) element.dispatchEvent(event);
                                });
                            } catch (e) {
                                console.log('Focus method partial failure:', e.message);
                            }
                        }, i * 30);
                    });
                },
                
                () => {
                    // Method 4: Create and interact with multiple temporary elements
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const elementTypes = ['input', 'button', 'div', 'span'];
                            const element = document.createElement(elementTypes[i % elementTypes.length]);
                            element.style.position = 'absolute';
                            element.style.left = '-9999px';
                            element.style.top = '-9999px';
                            element.style.opacity = '0';
                            element.style.pointerEvents = 'auto';
                            
                            if (element.tagName === 'INPUT') {
                                element.type = 'text';
                                element.value = `activity${i}`;
                            }
                            
                            document.body.appendChild(element);
                            
                            // Interact with element
                            element.focus();
                            element.click();
                            
                            if (element.tagName === 'INPUT') {
                                element.select();
                                const inputEvent = new InputEvent('input', { bubbles: true });
                                element.dispatchEvent(inputEvent);
                            }
                            
                            setTimeout(() => {
                                try {
                                    element.blur();
                                    if (element.parentNode) {
                                        element.parentNode.removeChild(element);
                                    }
                                } catch (e) {
                                    console.log('Element cleanup minor issue:', e.message);
                                }
                            }, 100);
                        }, i * 40);
                    }
                },
                
                () => {
                    // Method 5: Page interaction and scroll simulation
                    setTimeout(() => {
                        const currentScroll = window.scrollY;
                        
                        // Multiple scroll actions
                        window.scrollBy(0, 1);
                        setTimeout(() => window.scrollBy(0, -1), 25);
                        
                        // Wheel events
                        const wheelEvent = new WheelEvent('wheel', {
                            deltaY: Math.random() > 0.5 ? 1 : -1,
                            deltaX: 0,
                            bubbles: true,
                            cancelable: true
                        });
                        document.dispatchEvent(wheelEvent);
                        
                        // Page visibility and resize events
                        setTimeout(() => {
                            const resizeEvent = new Event('resize');
                            window.dispatchEvent(resizeEvent);
                        }, 50);
                    }, 10);
                },
                
                () => {
                    // Method 6: Touch events for comprehensive coverage
                    const touchEvents = ['touchstart', 'touchmove', 'touchend'];
                    touchEvents.forEach((eventType, i) => {
                        setTimeout(() => {
                            try {
                                const touch = new Touch({
                                    identifier: i,
                                    target: document.body,
                                    clientX: Math.random() * window.innerWidth,
                                    clientY: Math.random() * window.innerHeight
                                });
                                
                                const touchList = eventType === 'touchend' ? [] : [touch];
                                const touchEvent = new TouchEvent(eventType, {
                                    touches: touchList,
                                    targetTouches: touchList,
                                    changedTouches: [touch],
                                    bubbles: true,
                                    cancelable: true
                                });
                                
                                document.dispatchEvent(touchEvent);
                                document.body.dispatchEvent(touchEvent);
                            } catch (e) {
                                console.log('Touch events not supported:', e.message);
                            }
                        }, i * 30);
                    });
                },

                () => {
                    // Method 7: Pointer events (modern approach)
                    const pointerEvents = ['pointerdown', 'pointermove', 'pointerup'];
                    pointerEvents.forEach((eventType, i) => {
                        setTimeout(() => {
                            const event = new PointerEvent(eventType, {
                                pointerId: 1,
                                clientX: Math.random() * window.innerWidth,
                                clientY: Math.random() * window.innerHeight,
                                bubbles: true,
                                cancelable: true,
                                isPrimary: true
                            });
                            document.dispatchEvent(event);
                        }, i * 20);
                    });
                }
            ];

            // Execute all methods with staggered timing
            methods.forEach((method, index) => {
                setTimeout(() => {
                    try {
                        method();
                        console.log(`✅ Enhanced activity method ${index + 1} executed successfully`);
                    } catch (error) {
                        console.log(`❌ Enhanced activity method ${index + 1} failed:`, error.message);
                    }
                }, index * 100);
            });

            jigglesPerformed++;
            jigglesCount.textContent = jigglesPerformed;
            updateUptime();
            
            // Force page activity indicators
            if (document.hidden) {
                console.log('⚠️ Page is hidden - maintaining background activity');
                backgroundStatus.textContent = 'Background (Active)';
                backgroundStatus.style.background = 'rgba(255, 165, 0, 0.8)';
            } else {
                backgroundStatus.textContent = 'Foreground';
                backgroundStatus.style.background = 'rgba(0, 128, 0, 0.8)';
            }
            
            activityIndicator.style.background = '#00ff00';
            setTimeout(() => {
                activityIndicator.style.background = isActive ? '#00ff00' : '#ff6b6b';
            }, 500);
        }

        function startJiggler() {
            if (isActive) return;
            
            isActive = true;
            startTime = Date.now();
            jigglesPerformed = 0;
            
            statusEl.textContent = 'Active - Enhanced background-resistant jiggling every ' + intervalSlider.value + ' seconds';
            statusEl.className = 'status active';
            
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            
            // Use background-resistant timer
            jiggleInterval = createBackgroundResistantTimer(jiggleMouse, intervalSlider.value * 1000);
            
            // Start uptime counter
            uptimeInterval = setInterval(updateUptime, 1000);
            
            // Add visibility change handler
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // Initial jiggle
            jiggleMouse();
            
            console.log(`🚀 Enhanced mouse jiggler started with ${intervalSlider.value}s interval`);
            console.log('📊 Using multiple background-resistant timing methods');
            
            // Request wake lock if available
            requestWakeLock();
        }

        function stopJiggler() {
            if (!isActive) return;
            
            isActive = false;
            
            if (jiggleInterval) {
                jiggleInterval.stop();
                jiggleInterval = null;
            }
            
            clearInterval(uptimeInterval);
            clearInterval(pageActivityInterval);
            
            statusEl.textContent = 'Inactive - Click Start to begin';
            statusEl.className = 'status inactive';
            
            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            
            document.removeEventListener('visibilitychange', handleVisibility
